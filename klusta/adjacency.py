#!/usr/bin/python
#
# Prints adjacency graph to klusta based on MEA geometry.
#

import numpy as np

geometry = {
    0: (42, 85),
    1: (42, 100),
    2: (42, 71),
    3: (42, 57),
    4: (28, 100),
    5: (28, 85),
    6: (14, 100),
    7: (28, 71),
    8: (14, 85),
    9: (0, 85),
    10: (14, 71),
    11: (0, 71),
    12: (28, 57),
    13: (14, 57),
    14: (0, 57),
    15: (0, 42),
    16: (14, 42),
    17: (28, 42),
    18: (0, 28),
    19: (14, 28),
    20: (0, 14),
    21: (14, 14),
    22: (28, 28),
    23: (14, 0),
    24: (28, 14),
    25: (28, 0),
    26: (42, 42),
    27: (42, 28),
    28: (42, 0),
    29: (42, 14),
    30: (57, 14),
    31: (57, 0),
    32: (57, 28),
    33: (57, 42),
    34: (71, 0),
    35: (71, 14),
    36: (85, 0),
    37: (71, 28),
    38: (85, 14),
    39: (100, 14),
    40: (85, 28),
    41: (100, 28),
    42: (71, 42),
    43: (85, 42),
    44: (100, 42),
    45: (100, 57),
    46: (85, 57),
    47: (71, 57),
    48: (100, 71),
    49: (85, 71),
    50: (100, 85),
    51: (85, 85),
    52: (71, 71),
    53: (85, 100),
    54: (71, 85),
    55: (71, 100),
    56: (57, 57),
    57: (57, 71),
    58: (57, 100),
    59: (57, 85)
}

locations = -np.ones((101,101))
for (channel, location) in geometry.items():
    locations[location[0], location[1]] = channel

for (channel, location) in geometry.items():
    (x1, y1) = location
    for x2 in range(x1 + 1, 101):
        if locations[x2, y1] != -1:
            print('(%d, %d),' % (channel, locations[x2, y1]))
            break
    for y2 in range(y1 + 1, 101):
        if locations[x1, y2] != -1:
            print('(%d, %d),' % (channel, locations[x1, y2]))
            break


